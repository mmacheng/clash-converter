<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>üåÄ Clash ËäÇÁÇπËΩ¨Êç¢Âô®</title>
  <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcode.js/lib/qrcode.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600&family=Space+Grotesk:wght@500;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Space Grotesk', 'Segoe UI', sans-serif;
      background: linear-gradient(-45deg, #0f0c29, #302b63, #24243e);
      background-size: 400% 400%;
      color: #e0e0e0;
      min-height: 100vh;
      padding: 30px 20px;
      animation: gradient 15s ease infinite;
      transition: filter 0.5s;
    }

    @keyframes gradient {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    .container {
      max-width: 1000px;
      margin: 0 auto;
      backdrop-filter: blur(12px);
      background: rgba(255, 255, 255, 0.05);
      border-radius: 20px;
      padding: 32px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      transform: translateY(0);
      transition: transform 0.3s;
    }

    .container:hover {
      transform: translateY(-5px);
    }

    h1 {
      font-size: 2.2em;
      text-align: center;
      margin-bottom: 10px;
      background: linear-gradient(to right, #a188ff, #4fc3f7);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .subtitle {
      text-align: center;
      color: #aaa;
      font-size: 14px;
      margin-bottom: 24px;
    }

    .toggle-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.3);
      padding: 8px 14px;
      border-radius: 12px;
      cursor: pointer;
      backdrop-filter: blur(5px);
      font-size: 14px;
      transition: all 0.3s;
    }

    .toggle-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.05);
    }

    textarea {
      width: 100%;
      height: 220px;
      padding: 16px;
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      color: #fff;
      resize: vertical;
      backdrop-filter: blur(4px);
    }

    textarea:focus {
      outline: none;
      border-color: #4fc3f7;
      box-shadow: 0 0 15px rgba(79, 195, 247, 0.3);
    }

    button {
      margin-top: 16px;
      padding: 12px 24px;
      background: linear-gradient(45deg, #7b68ee, #4fc3f7);
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 7px 20px rgba(79, 195, 247, 0.4);
    }

    #result {
      margin-top: 24px;
      white-space: pre-wrap;
      background: rgba(0, 0, 0, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 18px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.6;
      max-height: 400px;
      overflow-y: auto;
      backdrop-filter: blur(4px);
    }

    .error { color: #ff5252; }
    .success { color: #69f0ae; }
    .info { color: #80deea; font-style: italic; }

    a.download-link {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      margin-top: 12px;
      padding: 10px 18px;
      background: linear-gradient(45deg, #00e676, #00c853);
      color: white;
      text-decoration: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
    }

    #qrcode {
      margin-top: 16px;
      text-align: center;
    }

    #qrcode img {
      border-radius: 12px;
      border: 2px solid #4fc3f7;
    }

    .drop-zone {
      border: 2px dashed #4fc3f7;
      border-radius: 12px;
      padding: 20px;
      text-align: center;
      margin: 16px 0;
      background: rgba(79, 195, 247, 0.1);
      color: #80deea;
      cursor: pointer;
      transition: all 0.3s;
    }

    .drop-zone:hover, .drop-zone.highlight {
      background: rgba(79, 195, 247, 0.2);
      border-color: #80deea;
      transform: scale(1.02);
    }

    @media (max-width: 768px) {
      .container {
        padding: 20px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
  </style>
</head>
<body>

  <button class="toggle-btn" onclick="alert('ÂΩìÂâç‰∏∫ÁÇ´ÈÖ∑‰∏ªÈ¢òÔºåÊöÇ‰∏çÊîØÊåÅÂàáÊç¢‰∫ÆËâ≤ÔºàÂèØÊâ©Â±ïÔºâ')"><i class="fas fa-moon"></i> ‰∏ªÈ¢ò</button>

  <div class="container">
    <h1>üåÄ Clash ËäÇÁÇπËΩ¨Êç¢Âô®</h1>
    <p class="subtitle">ÊîØÊåÅ vmess / ss / trojan / vless / hysteria / tuic / socks5</p>

    <div class="drop-zone" id="dropZone">
      <i class="fas fa-cloud-upload-alt" style="font-size: 24px; margin-bottom: 8px;"></i><br>
      ÊãñÊãΩËäÇÁÇπÊñá‰ª∂Âà∞ËøôÈáåÔºåÊàñÁÇπÂáªÈÄâÊã©
      <input type="file" id="fileInput" style="display: none" accept=".txt,.text">
    </div>

    <textarea id="inputNodes" placeholder="Á≤òË¥¥‰Ω†ÁöÑËäÇÁÇπÈìæÊé•ÔºåÊØèË°å‰∏Ä‰∏™Ôºö
vmess://xxxx
ss://yyyy
vless://zzzz
..."></textarea>

    <button onclick="convert()">
      <i class="fas fa-cogs"></i> ÁîüÊàê Clash ÈÖçÁΩÆ
    </button>

    <div id="result"></div>
  </div>

  <script>
    function base64Decode(str) {
      try {
        return decodeURIComponent(atob(str).split('').map(c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)).join(''));
      } catch (e) {
        console.error("Base64 Ëß£Á†ÅÂ§±Ë¥•:", e);
        return null;
      }
    }

    function parseVmess(url) {
      const match = url.match(/^vmess:\/\/(.+)$/);
      if (!match) return null;
      const data = match[1];
      let config;
      try {
        const padding = '='.repeat((4 - data.length % 4) % 4);
        const decoded = base64Decode(data + padding);
        if (!decoded) return null;
        config = JSON.parse(decoded);
      } catch (e) {
        return null;
      }
      return {
        name: config.ps || `vmess-${config.add}-${config.port}`,
        type: 'vmess',
        server: config.add,
        port: parseInt(config.port),
        uuid: config.id,
        alterId: parseInt(config.aid || 0),
        cipher: 'auto',
        udp: true,
        tls: config.tls === 'tls',
        servername: config.sni || config.host || '',
        'skip-cert-verify': !!config.skipCertVerify,
        network: config.net || 'tcp',
        'ws-path': config.net === 'ws' ? (config.path || '/') : undefined,
        'ws-headers': config.net === 'ws' && config.host ? { Host: config.host } : undefined
      };
    }

    function parseSs(url) {
      const match = url.match(/^ss:\/\/([^#]+)(?:#(.+))?$/);
      if (!match) return null;
      const content = match[1];
      const namePart = match[2] ? decodeURIComponent(match[2]) : null;
      let method, password, address, port;
      if (content.includes('@')) {
        const [auth, addr] = content.split('@');
        const [m, p] = auth.split(':');
        const [a, po] = addr.split(':');
        method = decodeURIComponent(m);
        password = decodeURIComponent(p);
        address = a;
        port = parseInt(po);
      } else {
        const decoded = base64Decode(content);
        if (!decoded) return null;
        const m = decoded.match(/^([^:]+):(.+)@([^:]+):(\d+)$/);
        if (!m) return null;
        method = m[1];
        password = m[2];
        address = m[3];
        port = parseInt(m[4]);
      }
      return {
        name: namePart || `ss-${address}-${port}`,
        type: 'ss',
        server: address,
        port,
        cipher: method,
        password,
        udp: true
      };
    }

    function parseTrojan(url) {
      try {
        const parsed = new URL(url);
        const password = parsed.username;
        const host = parsed.hostname;
        const port = parsed.port ? parseInt(parsed.port) : 443;
        const params = new URLSearchParams(parsed.search);
        const name = parsed.hash ? decodeURIComponent(parsed.hash.slice(1)) : `trojan-${host}-${port}`;
        return {
          name,
          type: 'trojan',
          server: host,
          port,
          password,
          udp: true,
          tls: true,
          sni: params.get('sni') || host,
          'skip-cert-verify': params.get('skipCertVerify') === 'true',
          alpn: params.get('alpn') ? params.get('alpn').split(',') : undefined
        };
      } catch (e) {
        return null;
      }
    }

    function parseSocks5(url) {
      const match = url.match(/^socks5:\/\/([^:]+):(\d+):([^:]+):(.+)$/);
      if (!match) return null;
      const [_, ip, port, user, pass] = match;
      return {
        name: `socks5-${ip}-${port}`,
        type: 'socks5',
        server: ip,
        port: parseInt(port),
        username: user,
        password: pass,
        udp: true
      };
    }

    function parseVless(url) {
      try {
        const parsed = new URL(url);
        const uuid = parsed.username;
        const host = parsed.hostname;
        const port = parsed.port ? parseInt(parsed.port) : 443;
        const params = new URLSearchParams(parsed.search);
        const name = parsed.hash ? decodeURIComponent(parsed.hash.slice(1)) : `vless-${host}-${port}`;
        return {
          name,
          type: 'vless',
          server: host,
          port,
          uuid,
          network: params.get('type') || 'tcp',
          tls: params.get('security') === 'tls' || params.get('security') === 'reality',
          servername: params.get('sni') || '',
          security: params.get('security') || 'none',
          reality: params.get('security') === 'reality',
          'reality-public-key': params.get('pbk') || '',
          'reality-short-id': params.get('sid') || '',
          'flow': params.get('flow') || '',
          'ws-path': params.get('path') || '/',
          'ws-headers': params.get('host') ? { Host: params.get('host') } : undefined,
          udp: true
        };
      } catch (e) {
        return null;
      }
    }

    function parseHysteria(url) {
      try {
        const parsed = new URL(url);
        const auth = parsed.username ? decodeURIComponent(parsed.username) : '';
        const host = parsed.hostname;
        const port = parsed.port ? parseInt(parsed.port) : 443;
        const params = new URLSearchParams(parsed.search);
        const name = parsed.hash ? decodeURIComponent(parsed.hash.slice(1)) : `hysteria-${host}-${port}`;
        return {
          name,
          type: 'hysteria',
          server: host,
          port,
          auth: auth,
          auth_str: auth,
          alpn: params.get('alpn')?.split(',') || ['h3'],
          protocol: params.get('protocol') || 'udp',
          'up': params.get('up') || '100M',
          'down': params.get('down') || '100M',
          obfs: params.get('obfs') || '',
          'skip-cert-verify': params.get('insecure') === '1',
          sni: params.get('sni') || host,
          udp: true
        };
      } catch (e) {
        return null;
      }
    }

    function parseTuic(url) {
      try {
        const match = url.match(/^tuic:\/\/([^:]+):([^@]+)@([^:]+):(\d+)(?:\?(.*))?#?(.*)$/);
        if (!match) return null;
        const [, uuid, pass, host, portStr, search = '', hash = ''] = match;
        const port = parseInt(portStr);
        const params = new URLSearchParams(search);
        const name = hash ? decodeURIComponent(hash) : `tuic-${host}-${port}`;
        return {
          name,
          type: 'tuic',
          server: host,
          port,
          uuid,
          password: pass,
          'ip': params.get('ip'),
          'sni': params.get('sni') || host,
          'congestion-controller': params.get('congestion_control') || 'bbr',
          'udp-relay-mode': params.get('udp_relay_mode') || 'native',
          'alpn': params.get('alpn')?.split(',') || ['h3'],
          'skip-cert-verify': params.get('allow_insecure') === '1',
          'disable-sni': params.get('disable_sni') === '1',
          udp: true
        };
      } catch (e) {
        return null;
      }
    }

    function parseProxyLine(line) {
      line = line.trim();
      if (!line) return null;
      if (line.startsWith('vmess://')) return parseVmess(line);
      if (line.startsWith('ss://')) return parseSs(line);
      if (line.startsWith('trojan://')) return parseTrojan(line);
      if (line.startsWith('socks5://')) return parseSocks5(line);
      if (line.startsWith('vless://')) return parseVless(line);
      if (line.startsWith('hysteria://')) return parseHysteria(line);
      if (line.startsWith('tuic://')) return parseTuic(line);
      return { error: true, text: line };
    }

    function generateClashConfig(proxies) {
      const config = {
        'mixed-port': 7890,
        'allow-lan': false,
        mode: 'Rule',
        'log-level': 'info',
        proxies,
        'proxy-groups': [
          { name: 'PROXY', type: 'select', proxies: proxies.map(p => p.name) },
          { name: 'Auto', type: 'url-test', url: 'http://www.gstatic.com/generate_204', interval: 300, tolerance: 50, proxies: proxies.map(p => p.name) }
        ],
        rules: [
          'GEOIP,CN,DIRECT',
          'DOMAIN-SUFFIX,google.com,PROXY',
          'DOMAIN-SUFFIX,youtube.com,PROXY',
          'DOMAIN-SUFFIX,github.com,PROXY',
          'MATCH,PROXY'
        ]
      };
      return jsyaml.dump(config, { indent: 2, noArrayIndent: false });
    }

    function convert() {
      const input = document.getElementById('inputNodes').value;
      const lines = input.split('\n');
      const proxies = [];
      const resultDiv = document.getElementById('result');
      resultDiv.innerHTML = '';

      let output = '';
      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed) continue;
        const proxy = parseProxyLine(trimmed);
        if (proxy && !proxy.error) {
          proxies.push(proxy);
          output += `<div class="success">‚úÖ ${proxy.name} (${proxy.type})</div>`;
        } else {
          output += `<div class="error">‚ùå Êó†Ê≥ïËß£Êûê: ${trimmed}</div>`;
        }
      }

      if (proxies.length === 0) {
        resultDiv.innerHTML = '<div class="error">‚ùå Ê≤°ÊúâÊúâÊïàËäÇÁÇπ</div>';
        return;
      }

      try {
        const yamlContent = generateClashConfig(proxies);
        const blob = new Blob([yamlContent], { type: 'text/yaml;charset=utf-8' });
        const url = URL.createObjectURL(blob);

        output += `<hr><p>ÂÖ± ${proxies.length} ‰∏™ËäÇÁÇπÔºö</p>`;
        output += `<a href="${url}" class="download-link" download="clash_config.yaml">
                     <i class="fas fa-download"></i> ‰∏ãËΩΩ clash_config.yaml
                   </a>`;
        output += `<div id="qrcode"><p>üì± Êâ´Á†Å‰∏ãËΩΩÈÖçÁΩÆÔºö</p></div>`;
        resultDiv.innerHTML = output;

        new QRCode(document.getElementById("qrcode").querySelector('p'), {
          text: url,
          width: 128,
          height: 128
        });

        document.querySelector('.download-link').onclick = () => {
          setTimeout(() => URL.revokeObjectURL(url), 1000);
        };
      } catch (e) {
        resultDiv.innerHTML = `<div class="error">‚ùå ÁîüÊàêÂ§±Ë¥•: ${e.message}</div>`;
      }
    }

    const dropZone = document.getElementById('dropZone');
    const fileInput = document.getElementById('fileInput');

    dropZone.addEventListener('click', () => fileInput.click());
    dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add('highlight'); });
    dropZone.addEventListener('dragleave', () => dropZone.classList.remove('highlight'));
    dropZone.addEventListener('drop', e => {
      e.preventDefault();
      dropZone.classList.remove('highlight');
      if (e.dataTransfer.files.length > 0) handleFile(e.dataTransfer.files[0]);
    });
    fileInput.addEventListener('change', e => {
      if (e.target.files.length > 0) handleFile(e.target.files[0]);
    });

    function handleFile(file) {
      const reader = new FileReader();
      reader.onload = e => document.getElementById('inputNodes').value = e.target.result;
      reader.readAsText(file);
    }
  </script>
</body>
</html>
